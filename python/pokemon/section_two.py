# オブジェクト指向を語る上で基本となるのが「クラス」というものの理解です。

# クラスとは何でしょうか？

# クラスとは、ざっくりいうと 「複数の変数/メソッドをまとめた設計図」 です。

# ここで例として「ポケモン( Pokemon )クラス」というものを考えてみます。

# Pokemon クラス
# プロパティ
# まずいきなり Pokemon クラスのコードを載せておきます。

# class Pokemon {
#     val name: String = “リザードン”
#     val type1: String = “ほのお”
#     val type2: String = “ひこう”
#     val hp: Int = 100
# }
class Pokemon :
    name = "リザードン"
    type1 = "ほのお"
    type2 = "ひこう"
    hp = 100

# ※Kotlin を知らない人に簡単に解説すると、 val が変数の定義、 : の右側がデータ型の宣言です。

# ここでは、ポケモンは以下のような特徴を持つと定義しています。

# 名前を持つ
# タイプを2種類持っている
# HPというパラメータを持っている
# 今回、変数の定義と同時に値を入れていますので、 名前はリザードン であり、 ほのおタイプ と ひこうタイプ を持ち、 HPが100 のポケモンが作られる、というクラスになっています。

# このように、クラスには 複数の変数を定義 する事ができます。この変数を 「プロパティ」 とか 「メンバ変数」 などと呼んだりします。

# メソッドの実装
# ポケモンは相手に攻撃する能力を持ちます。これを再現するために、 Pokemon クラスに attack() というメソッドを実装します。

# ※本当のポケモンは「わざ」を複数持っていますが、簡略化のために「攻撃」と表現しています。

# class Pokemon {
#     val name: String = “リザードン”
#     val type1: String = “ほのお”
#     val type2: String = “ひこう”
#     val hp: Int = 100
    
#     // 追加
#     fun attack() {
#         println("$name のこうげき！")
#     }
# }




class Pokemon:
    name = "リザードン"
    type1 = "ほのお"
    type2 = "ひこう"
    hp = 100

    @staticmethod
    def attack():
        print(f"{Pokemon.name}のこうげき!")



# プロパティと同様、クラスにはメソッドを定義することもできます。もちろん 複数のメソッド を定義することも可能です。

# このように、複数の変数やメソッドを定義して、一つのデータのまとまりを表現するのがクラスの基本です。

# クラスを「使う」？
# これで Pokemon クラスを一旦定義しました。それではこのクラスを実際に使ってみましょう…と言いたいのですが、最初に クラスは「設計図」である という話をしました。これはただの 設計図 なので、そのままでは使えません。

# クラスを使うためには、 インスタンス化 する必要があります。

# インスタンスとは
# インスタンスとは、クラス(設計図)を元に生成した オブジェクト(実体) です。

# たい焼きに例えると、 たい焼きの金型がクラス、金型で作った たい焼き そのものがインスタンス です。



# このインスタンスを生成することを インスタンス化する と言ったりします。

# インスタンスの生成は Kotlin だと以下のように書きます。

# val poke = Pokemon()

poke = Pokemon()

# これに日本語でコメントを付けるとすると「変数 poke に Pokemon クラスのインスタンスを生成して代入」という感じになります。

# これで Pokemon クラスをインスタンス化したので、以下のように「使う」事ができます。

# fun main() {
#     val poke = Pokemon()

#     println(poke.name)   // リザードン
#     println(poke.type1)  // ほのお
#     poke.attack()        // リザードン のこうげき！
# }

def main():
    poke = Pokemon()

    print(poke.name)
    print(poke.type1)
    poke.attack()

# 一般的に、クラスに定義したプロパティやメソッドには .{変数/メソッド名} でアクセスする事ができます。

# クラスとデータ型
poke = Pokemon()

# 上記コードは型を省略して書いていますが、省略せずに書くと以下のようになります。

poke: Pokemon = Pokemon()

# 変数 poke は Pokemon という型のインスタンスを持つという意味です。

# Pokemon クラスを作る とは、 「Pokemon 型」という 新しいデータ型を定義する 行為だと言えます。

# クラスで何が嬉しいのか？
# では、クラスがあると何が嬉しいのでしょうか？

# ポケモンは種類が多いことで有名ですが、例えばポケモンを 100匹 作りたいとします。

# クラスなしの場合
# このとき、クラスなしでポケモンの全パラメータを表現しようとすると、以下のようになります。

pokemon1Name = "ヒトカゲ"
pokemon2Name = "ゼニガメ"
...
pokemon100Name = "ミュウ"

pokemon1Type1 = "ほのお"
...
# 以下延々と続く

# 全ての変数を100個ずつ宣言することになります。単純に作業量が多いですし、名前の管理も大変です。

# さらに厄介なのが、 仕様変更があった時 です。

# 上司の鶴の一声で 「ポケモンにMPを実装しよう！」 という話が持ち上がりました。するとどうなるでしょう。 さらにMP用の変数を100個 追加しなければなりません。こういう変更時の作業量がえぐいプログラムを「変更に弱いプログラム」と言ったりします。

# 少し知識のある人はこう思ったかもしれません。「じゃあ配列(コレクション)を使えば良いのでは？」

pokemonName = ["ヒトカゲ", "ゼニガメ", ... "ミュウ"]
pokemonType1 = ...

# これは先ほどの例より少しだけ良い書き方になります。しかし "「ポケモンのパラメータを表す変数」であることを示すために変数名を「 pokemon_ 」から始める" など、ルールとして明文化しなければいけない事がたくさんありそうです。

# 1人で開発しているだけならこれでも何とかなりそうですが、チーム開発の場合、ルールが増えれば増えるほど足かせになっていきます。少しの伝達ミスがバグを引き起こす原因になり得ます。

# 例えばMPを追加する時、ルールの伝達ミスで変数名が

pokeMp = ...

# になっただけで、少し混乱が生まれる事が予想されます。

# クラスありの場合
# 同じことをクラスで行うと、以下のようになります。


# fun main() {
#     val pokemons: List<Pokemon> = createPokemon100() // ポケモンのインスタンスを100匹分作る処理とする
    
#     println(pokemons[0].name)    // 1匹目のポケモンの名前
#     println(pokemons[9].type1)    // 10匹目のポケモンのタイプ1
#     println(pokemons[99].attack()) // 100匹目のポケモンの攻撃
# }

def main():
    pokemons = createPokemon100()

    print(pokemons[0].name)
    print(pokemons[9].type1)
    print(pokemons[99].attack())



# クラスのインスタンスを100個作れば、変数をポケモンごとに定義する必要がなくなります。

# 変数の名前管理が楽になりますし、メソッドについても1個書くだけで使い回しが可能です。

# MPの追加についても、

# class Pokemon {
#     val name: String = "リザードン"
#     val type1: String = "ほのお"
#     val type2: String = "ひこう"
#     val hp: Int = 100
#     val mp: Int = 10 // 追加
    
#     fun attack() {
#         println("$name のこうげき!")
#     }
# }

# # 1行の追記でMPを追加できました。使う時も

# fun main() {
#     val poke = Pokemon()

#     println(poke.mp)   // 10
# }



class Pokemon:
    name = "リザードン"
    type1 = "ほのお"
    type2 = "ひこう"
    hp = 100

    @staticmethod
    def attack():
        print(f"{Pokemon.name}のこうげき!")

def main():

    poke = Pokemon()

    print(poke.hp)




# のように .mp でアクセス可能なため、「これはポケモンのMPというパラメータである」という事が一目で分かります。

# オブジェクト指向プログラミング
# 以上のように、クラスを活用してプログラミングを行っていく手法を

# 「オブジェクト指向プログラミング」（Object-Oriented Programming）

# と呼んでいます。